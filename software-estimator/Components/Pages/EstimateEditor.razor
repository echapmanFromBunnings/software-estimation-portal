@page "/estimate/{Id:guid}"
@using software_estimator.Data
@using software_estimator.Models
@using software_estimator.Services
@using System.Linq
@using software_estimator.Contracts
@using Microsoft.EntityFrameworkCore
@inject AppDbContext Db
@inject IPatternConfigService Patterns
@inject ISupportingConfigService Supporting
@inject ITeamConfigService Teams
@inject IRoleRatesService RoleRatesService
@inject ICostCalculator Cost
@inject Microsoft.AspNetCore.Components.NavigationManager Nav
@rendermode InteractiveServer
@implements IDisposable

@if (estimate is null)
{
    <p>Loading...</p>
}
else
{
    <h3>Edit Estimate</h3>
    <div class="row g-3">
        <div class="col-md-6">
            <label class="form-label">Name</label>
            <input class="form-control" @bind="estimate.Name" @bind:after="MarkAsChanged" />
            @if (string.IsNullOrWhiteSpace(estimate.Name))
            {
                <div class="text-danger small">Name is required.</div>
            }
        </div>
        <div class="col-md-6">
            <label class="form-label">Program Manager</label>
            <input class="form-control" @bind="estimate.Client" @bind:after="MarkAsChanged" />
        </div>
        <div class="col-md-6">
            <label class="form-label">Prepared By</label>
            <input class="form-control" @bind="estimate.PreparedBy" @bind:after="MarkAsChanged" placeholder="Enter your name" />
            <small class="text-muted">Who prepared this estimate</small>
        </div>
        <div class="col-md-6">
            <label class="form-label">Jira Idea URL</label>
            <input class="form-control" @bind="estimate.JiraIdeaUrl" @bind:after="MarkAsChanged" placeholder="Link to the original Jira Idea" />
            <small class="text-muted">Link to the Jira Idea that sparked this initiative</small>
        </div>
        <div class="col-md-6">
            <label class="form-label">Jira Initiative URL</label>
            <input class="form-control" @bind="estimate.JiraInitiativeUrl" @bind:after="MarkAsChanged" placeholder="Link to the Jira Initiative" />
            <small class="text-muted">Link to the Jira Initiative that owns this work</small>
        </div>
        <div class="col-12">
            <label class="form-label">Problem Statement</label>
            <textarea class="form-control" rows="4" @bind="estimate.ProblemStatement" @bind:after="MarkAsChanged" 
                      placeholder="Describe the problem this estimate aims to solve..."></textarea>
            <small class="text-muted">Clear description of the problem and what success looks like</small>
        </div>
        <div class="col-md-6">
            <label class="form-label">Assigned Teams (Optional)</label>
            <select multiple class="form-select" @onchange="OnTeamsChanged">
                @foreach (var team in availableTeams)
                {
                    <option value="@team.Key" selected="@(selectedTeamIds.Contains(team.Key) ? "selected" : null)">@team.Value</option>
                }
            </select>
            @if (!string.IsNullOrEmpty(estimate.TeamId) && teamDetails.ContainsKey(estimate.TeamId))
            {
                var team = teamDetails[estimate.TeamId];
                <div class="mt-2">
                    <small class="text-muted d-block">
                        <i class="fas fa-users me-1"></i>@team.Description
                    </small>
                    <small class="text-info d-block">
                        <i class="fas fa-briefcase me-1"></i>@team.FullTimeCount FTE, @team.ContractorCount Contractor
                    </small>
                    <small class="text-success d-block">
                        <i class="fas fa-cogs me-1"></i>Skills: @string.Join(", ", (IEnumerable<string>)team.Skills)
                    </small>
                </div>
            }
                else if (selectedTeamIds.Any())
            {
                    <div class="mt-2">
                        @foreach(var t in selectedTeamIds)
                        {
                            if (teamDetails.ContainsKey(t))
                            {
                                var team = teamDetails[t];
                                <div class="mb-2">
                                    <strong>@team.Name</strong>
                                    <div class="small text-muted">@team.Description</div>
                                </div>
                            }
                        }
                    </div>
            }
        </div>
    </div>

    <div class="mt-4">
        <h5>Assign Resources to Functional Lines</h5>
        <p class="small text-muted">Assign resources beneath each functional line and set percent utilisation (0-100%). Costs for the duration (sprints × sprint days) are calculated from these assignments.</p>
        <!-- The per-line assignment UI (collapsed by default) is rendered in the table below -->
    </div>
    <div class="row g-3 mt-2">
        <div class="col-md-4">
            <label class="form-label">Sprint length (days)</label>
            <input type="number" min="1" class="form-control" @bind="estimate.SprintLengthDays" @bind:after="MarkAsChanged" />
        </div>
        <!-- Assignments are now rendered inline beneath each functional line (collapsed by default) -->

        <div class="card mt-3 p-3">
            <h6>Add net-new resource</h6>
            <div class="row g-2 align-items-end">
                <div class="col-md-4">
                    <label class="form-label">Role</label>
                    <select class="form-select" @bind="newNetRole">
                        <option value="">-- select role --</option>
                        @foreach (var r in roleOptionsFullTime)
                        {
                            <option value="@r">@r</option>
                        }
                    </select>
                </div>
                <div class="col-md-2">
                    <label class="form-label">Daily rate</label>
                    <input class="form-control" type="number" min="0" @bind="newNetDaily" />
                </div>
                <div class="col-md-2">
                    <label class="form-label">Hourly</label>
                    <input class="form-control" type="number" min="0" @bind="newNetHourly" />
                </div>
                <div class="col-md-2">
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="isNetNew" @bind="newNetIsHire" />
                        <label class="form-check-label" for="isNetNew">Net new / hire</label>
                    </div>
                </div>
                <div class="col-md-2">
                    <button class="btn btn-primary" @onclick="AddNetNewResource">Add</button>
                </div>
            </div>
        </div>
        @if (showFullTimeModal)
        {
            <div class="modal d-block" tabindex="-1" style="background: rgba(0,0,0,0.5);">
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">Full-time resources</h5>
                            <button type="button" class="btn-close" aria-label="Close" @onclick="(()=> showFullTimeModal = false)"></button>
                        </div>
                        <div class="modal-body">
                            <div class="d-flex justify-content-end mb-2">
                                <div class="btn-group" role="group" aria-label="Rate filter">
                                    <button class="btn btn-sm @(modalRateFilter == RateFilter.Both ? "btn-primary" : "btn-outline-secondary")" @onclick="(() => { modalRateFilter = RateFilter.Both; })">All</button>
                                    <button class="btn btn-sm @(modalRateFilter == RateFilter.FTE ? "btn-primary" : "btn-outline-secondary")" @onclick="(() => { modalRateFilter = RateFilter.FTE; })">FTE</button>
                                    <button class="btn btn-sm @(modalRateFilter == RateFilter.Contractor ? "btn-primary" : "btn-outline-secondary")" @onclick="(() => { modalRateFilter = RateFilter.Contractor; })">Contractor</button>
                                </div>
                            </div>
                            <table class="table table-sm">
                                <thead><tr><th>#</th><th>Role</th><th>Hourly Rate</th><th>Daily Rate (8x Hourly)</th><th>Source</th></tr></thead>
                                <tbody>
                                    @{
                                        int idx = 1;
                                    }
                                    @foreach(var rr in defaultRoleRates.OrderByDescending(d => d.DailyRate))
                                    {
                                        var isContractor = rr.EmploymentType.Equals("Contractor", StringComparison.OrdinalIgnoreCase);
                                        if (modalRateFilter == RateFilter.FTE && isContractor) continue;
                                        if (modalRateFilter == RateFilter.Contractor && !isContractor) continue;
                                        <tr>
                                            <td>@(idx++)</td>
                                            <td>@rr.Role</td>
                                            <td>@rr.HourlyRate.ToString("C")</td>
                                            <td>@rr.DailyRate.ToString("C") <span class="text-muted">(@(rr.HourlyRate.ToString("C")) × 8)</span></td>
                                            <td>@(isContractor ? "Contractor" : "FTE")</td>
                                        </tr>
                                    }
                                </tbody>
                            </table>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" @onclick="(()=> showFullTimeModal = false)">Close</button>
                        </div>
                    </div>
                </div>
            </div>
        }
        @if (UnknownRoles.Any())
        {
            <div class="alert alert-warning mt-2">
                <div><strong>Unmapped roles detected:</strong> map them to an existing rate to use correct costs.</div>
                @foreach (var ur in UnknownRoles)
                {
                    <div class="d-flex align-items-center gap-2 mt-1">
                        <span class="badge text-bg-warning">@ur</span>
                        <span>→</span>
                        <select class="form-select form-select-sm" style="max-width:200px" @onchange="(e => MapRole(ur, e.Value?.ToString()))">
                            <option value="">-- select rate role --</option>
                            @foreach (var r in estimate.ResourceRates)
                            {
                                <option value="@r.Role">@r.Role</option>
                            }
                        </select>
                    </div>
                }
            </div>
        }
    </div>

    <div class="mt-4">
        <h5>Functional Work</h5>
        <div class="row">
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">Add Custom Line Item</div>
                    <div class="card-body">
                        <div class="d-flex gap-2">
                            <input class="form-control" placeholder="Custom title" @bind="newCustomTitle" />
                            <button class="btn btn-outline-primary" @onclick="AddCustomLine" aria-label="Add custom functional"><i class="fas fa-plus"></i></button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">Add from Common Pattern</div>
                    <div class="card-body">
                        <div class="d-flex gap-2">
                            <select class="form-select" @bind="selectedPatternKey">
                                <option value="">Select common pattern...</option>
                                @foreach (var p in patterns)
                                {
                                    <option value="@p.Key">@p.Title (@p.AverageSprints sprints)</option>
                                }
                            </select>
                            <button class="btn btn-outline-secondary" @onclick="AddPatternLine" aria-label="Add pattern functional"><i class="fas fa-plus"></i></button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
            <table class="table table-sm table-bordered mt-3">
                <thead class="table-light">
                    <tr>
                        <th style="width: 20%;">Title</th>
                        <th style="width: 15%;">Domain</th>
                        <th style="width: 30%;">Outcome</th>
                        <th style="width: 10%;">Source</th>
                        <th style="width: 10%;">Sprints</th>
                        <th style="width: 10%;">Line Cost</th>
                        <th style="width: 5%;">Flag</th>
                        <th style="width: 5%;"></th>
                    </tr>
                </thead>
                <tbody>
                    @foreach (var f in estimate.FunctionalItems)
                    {
                        var hasAssignments = f.AssignedResources != null && f.AssignedResources.Count > 0;
                        <tr class="@(hasAssignments ? null : "table-warning")">
                            <td><input class="form-control form-control-sm" @bind="f.Title" @bind:after="MarkAsChanged" /></td>
                            <td><input class="form-control form-control-sm" @bind="f.Domain" @bind:after="MarkAsChanged" /></td>
                            <td><textarea class="form-control form-control-sm" @bind="f.Outcome" @bind:after="MarkAsChanged" rows="2"></textarea></td>
                            <td>@f.SourceType</td>
                            <td><input type="number" step="0.25" min="0" class="form-control form-control-sm" @bind="f.Sprints" @bind:after="() => { UpdateDeviation(f); MarkAsChanged(); }" /></td>
                            <td>@GetFunctionalLineCost(f).ToString("C")</td>
                            <td>@(f.IsDeviationFlagged ? "⚠" : "")</td>
                            <td>
                                <div class="d-flex gap-1">
                                    <button class="btn btn-sm btn-outline-secondary" data-bs-toggle="collapse" data-bs-target="#assign-@f.Id" aria-expanded="false" aria-controls="assign-@f.Id">Assign</button>
                                    <button class="btn btn-sm btn-outline-danger" @onclick="(() => RemoveFunctional(f))"><i class="fas fa-trash"></i></button>
                                </div>
                            </td>
                        </tr>
                        <tr class="collapse-row">
                            <td colspan="8" class="p-0 border-0">
                                <div class="collapse" id="assign-@f.Id">
                                    <div class="card card-body">
                                        <div class="mb-2 small text-muted">Assign resources to this line and set percent utilisation (0-100%). Costs for the duration (sprints × sprint days) are calculated from these assignments.</div>
                                        <div class="row g-2">
                                            @foreach (var r in estimate.ResourceRates)
                                            {
                                                var sourceKey = r.SourceKey ?? string.Empty;
                                                var assigned = f.AssignedResources ?? new Dictionary<string, decimal>(StringComparer.OrdinalIgnoreCase);
                                                var isAssigned = assigned.ContainsKey(sourceKey);
                                                var pct = isAssigned ? assigned[sourceKey] : 100m;
                                                var label = FormatResourceLabel(r);
                                                var chkId = $"chk-{f.Id}-{sourceKey}";
                                                <div class="col-12 col-md-6">
                                                    <div class="form-check d-flex align-items-center gap-2">
                                                        <input class="form-check-input" type="checkbox" id="@chkId" checked="@isAssigned" @onchange="@(e => OnCheckboxChanged(f, sourceKey, e))" />
                                                        <label class="form-check-label" for="@chkId">@label</label>
                                                        <input class="form-control form-control-sm ms-2" style="width:100px;" type="number" min="0" max="100" step="1" value="@pct" @onchange="@(e => UpdateAssignmentPct(f, sourceKey, e))" disabled="@(!isAssigned)" />
                                                    </div>
                                                </div>
                                            }
                                        </div>
                                    </div>
                                </div>
                            </td>
                        </tr>
                    }
                </tbody>
            </table>
    </div>

    <div class="mt-4">
        <h5>Non-Functional / Supporting</h5>
        <div class="row">
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">Add Custom Non-Functional Item</div>
                    <div class="card-body">
                        <button class="btn btn-sm btn-outline-primary" @onclick="AddNonFunctional" aria-label="Add custom non-functional"><i class="fas fa-plus"></i></button>
                    </div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">Add from Supporting Activities</div>
                    <div class="card-body">
                        <div class="d-flex gap-2 align-items-center mb-2">
                            <select class="form-select form-select-sm" style="max-width: 300px;" @bind="selectedSupportKey">
                                <option value="">Select activity...</option>
                                @foreach (var a in supportActivities)
                                {
                                    <option value="@a.Key">@a.Title @((a.SuggestedPercentOfFunctional is not null ? $"({a.SuggestedPercentOfFunctional}% of functional)" : string.Empty))</option>
                                }
                            </select>
                            <button class="btn btn-sm btn-outline-secondary" @onclick="AddSelectedSupport" aria-label="Add selected supporting activity"><i class="fas fa-plus"></i></button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <table class="table table-sm table-bordered mt-3">
            <thead class="table-light">
                <tr>
                    <th>Title</th>
                    <th>Allocations (Role → Hours)</th>
                    <th>Item Cost</th>
                    <th></th>
                </tr>
            </thead>
            <tbody>
                @foreach (var n in estimate.NonFunctionalItems)
                {
                    <tr>
                        <td style="width: 25%;"><input class="form-control form-control-sm" @bind-value="n.Title" @bind-value:after="MarkAsChanged" /></td>
                        <td>
                            @* Allow either Sprints-based cost or legacy role→hours allocations. Show Sprints input and hide hours unless Sprints == 0 *@
                            <div class="d-flex align-items-center gap-2 mb-2">
                                <label class="form-label small mb-0">Sprints</label>
                                <input type="number" step="0.25" min="0" class="form-control form-control-sm" style="width:120px" @bind="n.Sprints" @bind:after="MarkAsChanged" />
                                <div class="small text-muted ms-2">If Sprints &gt; 0, allocations (hours) are ignored and cost is computed from squad per-sprint rates.</div>
                            </div>
                            @if (n.Sprints <= 0)
                            {
                                @foreach (var a in n.Allocations)
                                {
                                    <div class="d-flex gap-2 align-items-center mb-1">
                                        <select class="form-select form-select-sm" @bind="a.Role" @bind:after="() => { StateHasChanged(); MarkAsChanged(); }" style="width: 200px;">
                                            <option value="">-- Select Role --</option>
                                            @if (defaultRoleRates.Any())
                                            {
                                                @* Group by employment type for better UX *@
                                                <optgroup label="Full-Time Employees">
                                                    @foreach (var r in defaultRoleRates.Where(rr => !rr.EmploymentType.Equals("Contractor", StringComparison.OrdinalIgnoreCase)).OrderBy(rr => rr.Role))
                                                    {
                                                        <option value="@r.Role">@r.Role (FTE - @r.DailyRate.ToString("C")/day)</option>
                                                    }
                                                </optgroup>
                                                <optgroup label="Contractors">
                                                    @foreach (var r in defaultRoleRates.Where(rr => rr.EmploymentType.Equals("Contractor", StringComparison.OrdinalIgnoreCase)).OrderBy(rr => rr.Role))
                                                    {
                                                        <option value="@r.Role">@r.Role (Contractor - @r.DailyRate.ToString("C")/day)</option>
                                                    }
                                                </optgroup>
                                            }
                                            else
                                            {
                                                @* Fallback to team roles if defaultRoleRates not loaded *@
                                                @foreach (var r in estimate.ResourceRates.OrderBy(rr => rr.Role))
                                                {
                                                    <option value="@r.Role">@r.Role (@(r.Type == ResourceType.FTE ? "FTE" : "Contractor") - @r.DailyRate.ToString("C")/day)</option>
                                                }
                                            }
                                        </select>
                                        <input type="number" step="0.5" min="0" class="form-control form-control-sm" @bind="a.Hours" @bind:after="MarkAsChanged" style="width: 80px;" />
                                        <button class="btn btn-sm btn-outline-danger" @onclick="(() => RemoveAllocation(n, a))"><i class="fas fa-trash"></i></button>
                                    </div>
                                }
                                <button class="btn btn-sm btn-outline-secondary mt-1" @onclick="(() => AddAllocation(n))" aria-label="Add allocation role"><i class="fas fa-plus"></i></button>
                            }
                        </td>
                        <td style="width: 15%;">
                            @if (n.Sprints > 0)
                            {
                                // Compute cost from squad per-sprint: determine squad composition and multiply
                                var squad = new SquadComposition(
                                    estimate.ResourceRates.Count(r => r.Type == ResourceType.FTE),
                                    estimate.ResourceRates.Count(r => r.Type == ResourceType.Contractor),
                                    estimate.ResourceRates.Where(r => r.Type == ResourceType.FTE).DefaultIfEmpty(new ResourceRate { DailyRate = 0 }).Average(r => r.DailyRate),
                                    estimate.ResourceRates.Where(r => r.Type == ResourceType.Contractor).DefaultIfEmpty(new ResourceRate { DailyRate = 0 }).Average(r => r.DailyRate),
                                    estimate.SprintLengthDays
                                );
                                var perSprint = Cost.CalcSquadCostPerSprint(squad);
                                var formatted = Cost.CalcFunctionalLineCost(n.Sprints, perSprint).ToString("C");
                                @formatted
                            }
                            else
                            {
                                @CalcNonFunctionalCostWithDefaults(n).ToString("C")
                            }
                        </td>
                        <td style="width: 5%;">
                            <button class="btn btn-sm btn-outline-danger" @onclick="(() => RemoveNonFunctional(n))" aria-label="Remove non-functional"><i class="fas fa-times"></i></button>
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    </div>

    <div class="mt-4">
        <h5>Totals</h5>
        <div class="card">
            <div class="card-body">
                <dl class="row mb-0">
                    <dt class="col-sm-3">Functional Subtotal</dt>
                    <dd class="col-sm-9">@FunctionalSubtotal.ToString("C")</dd>

                    <dt class="col-sm-3">Non-functional Subtotal</dt>
                    <dd class="col-sm-9">@NonFunctionalSubtotal.ToString("C")</dd>

                    <dt class="col-sm-3">Subtotal</dt>
                    <dd class="col-sm-9">@Subtotal.ToString("C")</dd>

                    <dt class="col-sm-3">Contingency</dt>
                    <dd class="col-sm-9">
                        <div class="d-flex align-items-center gap-2">
                            <div class="input-group" style="width: 120px;">
                                <input type="number" 
                                       class="form-control form-control-sm" 
                                       @bind="estimate.ContingencyPercent" 
                                       @oninput="OnContingencyChanged"
                                       min="0" 
                                       max="100" 
                                       step="0.1" 
                                       placeholder="0.0" />
                                <span class="input-group-text">%</span>
                            </div>
                            <span class="text-muted">= @((Total - Subtotal).ToString("C"))</span>
                        </div>
                    </dd>

                    <dt class="col-sm-3 border-top pt-2 mt-2">Total</dt>
                    <dd class="col-sm-9 border-top pt-2 mt-2"><strong>@Total.ToString("C")</strong></dd>
                </dl>
            </div>
        </div>
    </div>

    <div class="mt-3 d-flex gap-2 align-items-center">
        <button class="btn btn-primary" @onclick="() => Save(false)" disabled="@(!IsValid || isSaving || isAutoSaving)">
            @if (isSaving)
            {
                <span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span><span>Saving...</span>
            }
            else
            {
                <span>Save</span>
            }
        </button>
        @if (isAutoSaving)
        {
            <div class="d-flex align-items-center text-muted">
                <span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true" style="width: 0.8rem; height: 0.8rem;"></span>
                <small>Auto-saving...</small>
            </div>
        }
        else if (hasUnsavedChanges && !isSaving)
        {
            <div class="text-warning">
                <small><i class="fas fa-exclamation-circle me-1"></i>Unsaved changes</small>
            </div>
        }
        else if (!hasUnsavedChanges && !string.IsNullOrEmpty(saveMessage) && saveMessageClass == "text-success")
        {
            <div class="text-success">
                <small><i class="fas fa-check-circle me-1"></i>All changes saved</small>
            </div>
        }
        <button class="btn btn-secondary" @onclick="Clone" disabled="@isSaving">Clone</button>
        <button class="btn btn-outline-secondary" @onclick="AddSuggestedOverheads" disabled="@isSaving">Add Suggested Overheads</button>
        <a class="btn btn-outline-success" href="/api/estimates/@Id/json" target="_blank">Export JSON</a>
        <a class="btn btn-outline-success" href="/api/estimates/@Id/csv" target="_blank">Export CSV</a>
        <a class="btn btn-outline-success" href="/api/estimates/@Id/pdf" target="_blank">Export PDF</a>
        <a class="btn btn-outline-dark" href="/estimates">Back</a>
        @if (!string.IsNullOrEmpty(saveMessage))
        {
            <div class="ms-3 @saveMessageClass">@saveMessage</div>
        }
    </div>
}

@code {
    [Parameter] public Guid Id { get; set; }
    private Estimate? estimate;
    private List<CommonPattern> patterns = new();
    private List<SupportingActivity> supportActivities = new();
    private Dictionary<string, string> availableTeams = new();
    private Dictionary<string, dynamic> teamDetails = new();
    private string? newCustomTitle;
    private string? selectedPatternKey;
    // Multi-team selection state
    private HashSet<string> selectedTeamIds = new();
    private List<ResourceRate> modalFullTimeResources = new();
    private bool showFullTimeModal = false;
    // All default role rates loaded from config (used for modal)
    private List<RoleRateEntry> defaultRoleRates = new();
    private enum RateFilter { FTE, Contractor, Both }
    private RateFilter modalRateFilter = RateFilter.Both;
    // Stable numbering map to keep numbers consistent across rebuilds
    private Dictionary<string,int> resourceNumberMap = new Dictionary<string,int>(StringComparer.OrdinalIgnoreCase);

    private async Task OnTeamsChanged(ChangeEventArgs e)
    {
        // Multi-select change can provide different types depending on runtime (string, string[] or IEnumerable)
        selectedTeamIds.Clear();
        var value = e?.Value;
        if (value is null)
        {
            // nothing selected
        }
        else if (value is string s)
        {
            // Blazor sometimes provides a comma-separated string
            if (!string.IsNullOrWhiteSpace(s))
            {
                var parts = s.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
                foreach (var p in parts) selectedTeamIds.Add(p);
            }
        }
        else if (value is string[] arr)
        {
            foreach (var p in arr) if (!string.IsNullOrWhiteSpace(p)) selectedTeamIds.Add(p);
        }
        else if (value is IEnumerable<object> objs)
        {
            foreach (var o in objs)
            {
                var part = o?.ToString();
                if (!string.IsNullOrWhiteSpace(part)) selectedTeamIds.Add(part!);
            }
        }
        else
        {
            // Fallback: try ToString and split
            var fallback = value.ToString() ?? string.Empty;
            if (!string.IsNullOrWhiteSpace(fallback))
            {
                var parts = fallback.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
                foreach (var p in parts) selectedTeamIds.Add(p);
            }
        }
        Console.WriteLine($"[EstimateEditor] OnTeamsChanged selected: {string.Join(',', selectedTeamIds)}");
        isBulkResourceOperation = true;
        try
        {
            await RebuildResourceListFromTeams();
            MarkAsChanged(); // Mark changed after rebuilding is complete
        }
        finally
        {
            isBulkResourceOperation = false;
        }
        StateHasChanged();
    }

    private void OnContingencyChanged(ChangeEventArgs e)
    {
        // Parse and validate the contingency percentage
        if (decimal.TryParse(e.Value?.ToString(), out var value))
        {
            // Clamp the value between 0 and 100
            estimate!.ContingencyPercent = Math.Max(0, Math.Min(100, value));
        }
        
        MarkAsChanged(); // Trigger auto-save
        StateHasChanged(); // Update UI to reflect new calculations
    }

    // OnTeamsArrayChanged removed; using OnTeamsChanged which handles multiple input shapes

    private Task RebuildResourceListFromTeams()
    {
        // capture previous keys so we can remove assignments for resources that no longer exist
        var previousKeys = estimate!.ResourceRates.Select(r => r.SourceKey).Where(k => !string.IsNullOrWhiteSpace(k)).ToList();

        // Keep net-new resources (IsNetNew == true) - create copies to avoid EF tracking issues
        var netNew = estimate.ResourceRates.Where(r => r.IsNetNew).Select(n => new ResourceRate
        {
            Role = n.Role,
            Type = n.Type,
            DailyRate = n.DailyRate,
            HourlyRate = n.HourlyRate,
            SourceKey = string.IsNullOrWhiteSpace(n.SourceKey) ? $"NetNew-{Guid.NewGuid():N}" : n.SourceKey,
            SourceTeamName = string.IsNullOrWhiteSpace(n.SourceTeamName) ? "NetNew" : n.SourceTeamName,
            IsNetNew = true
        }).ToList();

        // Clear and detach existing resource rates to avoid EF tracking conflicts
        foreach (var rate in estimate.ResourceRates.ToList())
        {
            if (Db.Entry(rate).State != EntityState.Detached)
            {
                Db.Entry(rate).State = EntityState.Deleted;
            }
        }
        estimate.ResourceRates.Clear();

        // For each selected team, add their FullTime roles according to counts, and create stable SourceKey
        modalFullTimeResources.Clear();
        foreach (var tid in selectedTeamIds)
        {
            if (!teamDetails.ContainsKey(tid)) continue;
            var team = Teams.FindById(tid);
            if (team is null) continue;
            // sanitize team name to a short key: replace spaces with '-' then keep alnum/_/-
            string Sanitize(string s)
            {
                var replaced = (s ?? string.Empty).Replace(' ', '-').ToLowerInvariant();
                return new string(replaced.Where(c => char.IsLetterOrDigit(c) || c == '-' || c == '_').ToArray()).Trim('-');
            }
            var tkey = Sanitize(team.Name);
                    foreach (var tr in team.Roles.Where(r => r.EmploymentType == "FullTime"))
            {
                for (int i = 0; i < tr.Count; i++)
                {
                    var seq = i + 1; // 1-based sequence
                    // include role in the source key to avoid collisions when multiple roles exist
                    var roleToken = new string(tr.Role.ToLowerInvariant().Where(c => char.IsLetterOrDigit(c) || c=='-' || c=='_').ToArray());
                    var sourceKey = $"{tkey}-{roleToken}-{(tr.EmploymentType.Equals("Contractor", StringComparison.OrdinalIgnoreCase) ? "CTR" : "FTE")}-{seq}";
                    var rate = EstimateRoleRateFromConfig(tr.Role, ResourceType.FTE);
                    rate.SourceKey = sourceKey;
                    rate.SourceTeamId = tid;
                    rate.SourceTeamName = team.Name;
                    rate.IsNetNew = false;
                    estimate.ResourceRates.Add(rate);
                }

                // Add unique role entry to modalFullTimeResources for informational modal
                if (!modalFullTimeResources.Any(m => m.Role.Equals(tr.Role, StringComparison.OrdinalIgnoreCase)))
                {
                    var r = EstimateRoleRateFromConfig(tr.Role, ResourceType.FTE);
                    modalFullTimeResources.Add(r);
                }
            }
            Console.WriteLine($"[EstimateEditor] Built resources for team {team.Id} ({team.Name}) - Roles: {team.Roles.Count}");
        }

        // re-add net-new entries
        foreach (var n in netNew) estimate.ResourceRates.Add(n);

        // Assign stable numbers without resetting history (preserve previous mapping)
        EnsureStaticNumbersAssigned();

        // Remove assignments that referenced resources no longer present
        var currentKeys = estimate.ResourceRates.Select(r => r.SourceKey).Where(k => !string.IsNullOrWhiteSpace(k)).ToHashSet(StringComparer.OrdinalIgnoreCase);
        var removedKeys = previousKeys.Where(k => !currentKeys.Contains(k)).ToList();
        foreach (var k in removedKeys)
        {
            if (!string.IsNullOrWhiteSpace(k) && resourceNumberMap.ContainsKey(k))
            {
                RemoveResourceFromAssignments(k);
            }
        }

        return Task.CompletedTask;
    }

    // Full-time role options for dropdowns
    private List<string> roleOptionsFullTime = new();

    private ResourceRate EstimateRoleRateFromConfig(string role, ResourceType type)
    {
        var rr = estimate!.ResourceRates.FirstOrDefault(r => r.Role.Equals(role, StringComparison.OrdinalIgnoreCase) && r.Type == type);
        if (rr is not null)
        {
            // return a shallow copy
            return new ResourceRate { Role = rr.Role, Type = rr.Type, DailyRate = rr.DailyRate, HourlyRate = rr.HourlyRate };
        }
        // Look up from RoleRatesService
        var defaults = RoleRatesService.GetDefaultRatesAsync().Result;
        var def = defaults.FirstOrDefault(d => d.Role.Equals(role, StringComparison.OrdinalIgnoreCase) && ((type == ResourceType.Contractor && d.EmploymentType.Equals("Contractor", StringComparison.OrdinalIgnoreCase)) || (type == ResourceType.FTE && !d.EmploymentType.Equals("Contractor", StringComparison.OrdinalIgnoreCase))));
        if (def is not null)
        {
            var hourly = def.HourlyRate > 0 ? def.HourlyRate : Math.Round(def.DailyRate / 8m, 3);
            return new ResourceRate { Role = def.Role, Type = type, DailyRate = def.DailyRate, HourlyRate = hourly };
        }
        // fallback
        return new ResourceRate { Role = role, Type = type, DailyRate = 0, HourlyRate = 0 };
    }

    protected override async Task OnInitializedAsync()
    {
        estimate = Db.Estimates
            .Where(e => e.Id == Id)
            .Select(e => e)
            .FirstOrDefault();
        if (estimate is null)
        {
            // Redirect to list if not found
            Nav.NavigateTo("/estimates");
            return;
        }
        // Load related collections
        Db.Entry(estimate).Collection(e => e.FunctionalItems).Load();
        Db.Entry(estimate).Collection(e => e.NonFunctionalItems).Load();
        foreach (var n in estimate.NonFunctionalItems)
        {
            Db.Entry(n).Collection(x => x.Allocations).Load();
        }
        Db.Entry(estimate).Collection(e => e.ResourceRates).Load();
        Db.Entry(estimate).Collection(e => e.RoleMappings).Load();
        patterns = (await Patterns.GetPatternsAsync()).ToList();
        supportActivities = (await Supporting.GetActivitiesAsync()).ToList();
        
        // Load teams in a simple way
        await LoadTeams();
        // Initialize selected teams from the estimate (legacy single TeamId) or from existing resource rates
        try
        {
            selectedTeamIds.Clear();
            if (!string.IsNullOrWhiteSpace(estimate.TeamId)) selectedTeamIds.Add(estimate.TeamId!);
            var fromRates = estimate.ResourceRates.Select(r => r.SourceTeamId).Where(id => !string.IsNullOrWhiteSpace(id)).Distinct(StringComparer.OrdinalIgnoreCase).ToList();
            foreach (var id in fromRates) selectedTeamIds.Add(id!);
            // Ensure resource list reflects selected teams
            await RebuildResourceListFromTeams();
        }
        catch { }
        // Populate full-time role options
        try
        {
            var defs = await RoleRatesService.GetDefaultRatesAsync();
            defaultRoleRates = defs.ToList();
            roleOptionsFullTime = defs.Where(d => d.EmploymentType.Equals("FullTime", StringComparison.OrdinalIgnoreCase)).Select(d => d.Role).Distinct(StringComparer.OrdinalIgnoreCase).OrderBy(r => r).ToList();
        }
        catch { roleOptionsFullTime = new(); defaultRoleRates = new(); }
        
        // Initialize auto-save timer
        InitializeAutoSave();
    }
    
    private void InitializeAutoSave()
    {
        autoSaveTimer?.Dispose();
        autoSaveTimer = new Timer(async _ => await TryAutoSave(), null, Timeout.Infinite, Timeout.Infinite);
    }
    
    private async Task TryAutoSave()
    {
        if (hasUnsavedChanges && IsValid && !isSaving && !isAutoSaving && !isBulkResourceOperation)
        {
            await InvokeAsync(async () =>
            {
                await Save(true);
            });
        }
    }
    
    private void MarkAsChanged()
    {
        hasUnsavedChanges = true;
        lastChangeTime = DateTime.Now;
        
        // Reset the auto-save timer
        autoSaveTimer?.Change(AutoSaveDelayMs, Timeout.Infinite);
        
        StateHasChanged();
    }

    private async Task LoadTeams()
    {
        try
        {
            var teams = await Teams.GetActiveTeamsAsync();
            availableTeams = teams.ToDictionary(t => t.Id, t => $"{t.Name} ({GetSimpleTeamSummary(t)})");
            
            foreach (var team in teams)
            {
                teamDetails[team.Id] = new 
                { 
                    Name = team.Name, 
                    Description = team.Description, 
                    Skills = team.Skills,
                    MemberCount = team.Roles.Sum(r => r.Count),
                    FullTimeCount = team.Roles.Where(r => r.EmploymentType == "FullTime").Sum(r => r.Count),
                    ContractorCount = team.Roles.Where(r => r.EmploymentType == "Contractor").Sum(r => r.Count)
                };
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading teams: {ex.Message}");
            availableTeams = new();
            teamDetails = new();
        }
    }

    private string GetSimpleTeamSummary(dynamic team)
    {
        try
        {
            var roles = team.Roles as IEnumerable<dynamic>;
            var memberCount = roles?.Sum(r => (int)r.Count) ?? 0;
            var roleTypes = roles?.Select(r => (string)r.Role).Distinct().Count() ?? 0;
            return $"{memberCount} members, {roleTypes} roles";
        }
        catch
        {
            return "Team info";
        }
    }

    private void AddRate()
    {
        estimate!.ResourceRates.Add(new ResourceRate { Role = "Role", DailyRate = 800 });
    }
    private void RemoveRate(ResourceRate r)
    {
        estimate!.ResourceRates.Remove(r);
    }

    private void AddCustomLine()
    {
        if (string.IsNullOrWhiteSpace(newCustomTitle)) return;
        estimate!.FunctionalItems.Add(new FunctionalLineItem { Title = newCustomTitle!, SourceType = LineSourceType.Custom, Sprints = 0.5m });
        newCustomTitle = string.Empty;
    }

    private void AddPatternLine()
    {
        if (string.IsNullOrWhiteSpace(selectedPatternKey)) return;
        var p = patterns.FirstOrDefault(x => x.Key == selectedPatternKey);
        if (p is null) return;
        var item = new FunctionalLineItem
        {
            Title = p.Title,
            SourceType = LineSourceType.CommonPattern,
            PatternKey = p.Key,
            AverageSprints = p.AverageSprints,
            Sprints = p.AverageSprints
        };
        item.IsDeviationFlagged = Cost.IsDeviation(item.AverageSprints, item.Sprints);
        estimate!.FunctionalItems.Add(item);
    }

    private void RemoveFunctional(FunctionalLineItem f)
    {
        estimate!.FunctionalItems.Remove(f);
    }

    private void UpdateDeviation(FunctionalLineItem f)
    {
        f.IsDeviationFlagged = Cost.IsDeviation(f.AverageSprints, f.Sprints);
    }

    private void AddNonFunctional()
    {
        estimate!.NonFunctionalItems.Add(new NonFunctionalItem { Title = "Meetings" });
    }

    private string? selectedSupportKey;
    private void AddSelectedSupport()
    {
        if (string.IsNullOrWhiteSpace(selectedSupportKey)) return;
        var act = supportActivities.FirstOrDefault(a => a.Key == selectedSupportKey);
        if (act is null) return;
        AddSupportActivity(act);
        selectedSupportKey = string.Empty;
    }

    private void AddAllSupport()
    {
        foreach (var act in supportActivities)
        {
            AddSupportActivity(act);
        }
    }

    private void AddSupportActivity(SupportingActivity act)
    {
        if (estimate!.NonFunctionalItems.Any(n => n.Title.Equals(act.Title, StringComparison.OrdinalIgnoreCase))) return;
        var item = new NonFunctionalItem { Title = act.Title };

        // Start with roles from defaults if present; otherwise pick a reasonable role
        var roles = new List<(string role, decimal weight)>();
        if (act.DefaultAllocations is { Count: > 0 })
        {
            var totalWeight = act.DefaultAllocations.Sum(a => a.Hours > 0 ? a.Hours : 0);
            foreach (var da in act.DefaultAllocations)
            {
                var w = da.Hours > 0 ? da.Hours : 0;
                roles.Add((da.Role, w));
            }
            // If all weights are zero, distribute equally
            if (totalWeight == 0 && roles.Count > 0)
            {
                for (int i = 0; i < roles.Count; i++) roles[i] = (roles[i].role, 1);
            }
        }
        else
        {
            // Fallback to Developer role if present; else first available role; else empty
            var dev = estimate.ResourceRates.FirstOrDefault(r => r.Role.Equals("Developer", StringComparison.OrdinalIgnoreCase))?.Role
                      ?? estimate.ResourceRates.FirstOrDefault()?.Role;
            if (!string.IsNullOrWhiteSpace(dev)) roles.Add((dev!, 1));
        }

        // Try to compute hours from suggested percent of functional subtotal
        var pct = act.SuggestedPercentOfFunctional ?? 0m;
        var canCompute = pct > 0 && FunctionalSubtotal > 0 && estimate.ResourceRates.Any();
        if (canCompute && roles.Count > 0)
        {
            var targetCost = FunctionalSubtotal * (pct / 100m);
            var totalWeight = roles.Sum(r => r.weight);
            if (totalWeight == 0) totalWeight = roles.Count; // equal split fallback

            // Average hourly fallback if a role has no rate
            decimal avgHourly = 0m;
            if (estimate.ResourceRates.Any())
            {
                var hourlies = estimate.ResourceRates.Select(r => r.HourlyRate > 0 ? r.HourlyRate : (r.DailyRate > 0 ? r.DailyRate / 8m : 0m))
                                                     .Where(h => h > 0).ToList();
                avgHourly = hourlies.Count > 0 ? hourlies.Average() : 0m;
            }

            foreach (var (role, weight) in roles)
            {
                var mappedRole = ResolveRole(role);
                var rate = estimate.ResourceRates.FirstOrDefault(r => r.Role.Equals(mappedRole, StringComparison.OrdinalIgnoreCase));
                var hourly = rate is not null
                    ? (rate.HourlyRate > 0 ? rate.HourlyRate : (rate.DailyRate > 0 ? rate.DailyRate / 8m : 0m))
                    : 0m;
                if (hourly <= 0) hourly = avgHourly;
                var shareCost = targetCost * (weight / totalWeight);
                var hours = hourly > 0 ? Math.Round(shareCost / hourly, 1, MidpointRounding.AwayFromZero) : 0m;
                item.Allocations.Add(new ResourceAllocation { Role = mappedRole ?? role, Hours = hours });
            }
        }
        else
        {
            // No computation possible: just add zero-hour allocations for roles
            foreach (var (role, _) in roles)
            {
                item.Allocations.Add(new ResourceAllocation { Role = ResolveRole(role) ?? role, Hours = 0 });
            }
        }

        estimate.NonFunctionalItems.Add(item);
    }

    private void RemoveNonFunctional(NonFunctionalItem n)
    {
        estimate!.NonFunctionalItems.Remove(n);
    }

    // Custom cost calculation that handles both team roles and default role rates
    private decimal CalcNonFunctionalCostWithDefaults(NonFunctionalItem item)
    {
        decimal total = 0m;
        foreach (var a in item.Allocations)
        {
            var (hourlyRate, _) = GetRoleRateInfo(a.Role);
            total += a.Hours * hourlyRate;
        }
        return Decimal.Round(total, 2);
    }

    // Helper method to get role rate info from either team rates or default rates
    private (decimal hourlyRate, ResourceType type) GetRoleRateInfo(string role)
    {
        // First check team-assigned resource rates
        var teamRate = estimate?.ResourceRates.FirstOrDefault(r => r.Role.Equals(role, StringComparison.OrdinalIgnoreCase));
        if (teamRate != null)
        {
            var hourly = teamRate.HourlyRate > 0 ? teamRate.HourlyRate : 
                        (teamRate.DailyRate > 0 ? teamRate.DailyRate / 8m : 0m);
            return (hourly, teamRate.Type);
        }
        
        // Check default role rates
        var defaultRate = defaultRoleRates.FirstOrDefault(r => r.Role.Equals(role, StringComparison.OrdinalIgnoreCase));
        if (defaultRate != null)
        {
            var hourly = defaultRate.HourlyRate > 0 ? defaultRate.HourlyRate :
                        (defaultRate.DailyRate > 0 ? defaultRate.DailyRate / 8m : 0m);
            var type = defaultRate.EmploymentType.Equals("Contractor", StringComparison.OrdinalIgnoreCase) ? 
                      ResourceType.Contractor : ResourceType.FTE;
            return (hourly, type);
        }
        
        // Fallback
        return (0m, ResourceType.FTE);
    }
    
    private void AddAllocation(NonFunctionalItem n)
    {
        // Use first role from defaultRoleRates if available, otherwise fallback to team roles
        var defaultRole = defaultRoleRates.FirstOrDefault()?.Role ?? 
                         estimate!.ResourceRates.FirstOrDefault()?.Role ?? 
                         "Developer";
        n.Allocations.Add(new ResourceAllocation { Role = defaultRole, Hours = 1 });
        MarkAsChanged();
    }

    private void RemoveAllocation(NonFunctionalItem n, ResourceAllocation a)
    {
        n.Allocations.Remove(a);
    }

    private SquadComposition Squad => GetAllocatedSquadComposition();

    private SquadComposition GetAllocatedSquadComposition()
    {
        if (estimate is null) 
            return new SquadComposition(0, 0, 0, 0, 10);

        // Get all distinct resource keys that are allocated to functional line items
        var allocatedResourceKeys = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        
        foreach (var functional in estimate.FunctionalItems)
        {
            var assignedResources = functional.AssignedResources ?? new Dictionary<string, decimal>();
            foreach (var resourceKey in assignedResources.Keys)
            {
                if (!string.IsNullOrWhiteSpace(resourceKey))
                {
                    allocatedResourceKeys.Add(resourceKey);
                }
            }
        }

        // Find the actual resource rates for these allocated resources
        var allocatedResources = estimate.ResourceRates
            .Where(r => allocatedResourceKeys.Contains(r.SourceKey ?? ""))
            .ToList();

        if (allocatedResources.Count == 0)
            return new SquadComposition(0, 0, 0, 0, estimate.SprintLengthDays);

        var fteResources = allocatedResources.Where(r => r.Type == ResourceType.FTE).ToList();
        var contractorResources = allocatedResources.Where(r => r.Type == ResourceType.Contractor).ToList();

        return new SquadComposition(
            fteResources.Count,
            contractorResources.Count,
            fteResources.DefaultIfEmpty(new ResourceRate { DailyRate = 0 }).Average(r => r.DailyRate),
            contractorResources.DefaultIfEmpty(new ResourceRate { DailyRate = 0 }).Average(r => r.DailyRate),
            estimate.SprintLengthDays
        );
    }

    private decimal SquadPerSprint => Cost.CalcSquadCostPerSprint(Squad);
    // Functional subtotal now sums per-line costs computed from assigned resources (utilisation-based)
    private decimal FunctionalSubtotal => estimate is null ? 0 : estimate.FunctionalItems.Sum(f => GetFunctionalLineCost(f));
    private decimal NonFunctionalSubtotal => estimate is null ? 0 : estimate.NonFunctionalItems.Sum(n => 
        n.Sprints > 0 ? 
            Cost.CalcFunctionalLineCost(n.Sprints, SquadPerSprint) : 
            CalcNonFunctionalCostWithDefaults(n));
    private decimal Subtotal => FunctionalSubtotal + NonFunctionalSubtotal;
    private decimal Total => estimate is null ? 0 : Cost.ApplyContingency(Subtotal, estimate.ContingencyPercent);

    // UI state for saving
    private bool isSaving = false;
    private bool isAutoSaving = false;
    private string? saveMessage;
    private string saveMessageClass = "text-success";
    // Auto-save functionality
    private Timer? autoSaveTimer;
    private bool hasUnsavedChanges = false;
    private DateTime lastChangeTime = DateTime.Now;
    private const int AutoSaveDelayMs = 3000; // 3 seconds after last change
    private bool isBulkResourceOperation = false; // Flag to prevent auto-save during bulk operations
    // Net-new resource temporary fields
    private string? newNetRole;
    private decimal newNetDaily = 0m;
    private decimal newNetHourly = 0m;
    private bool newNetIsHire = false;

    private void AddNetNewResource()
    {
        if (string.IsNullOrWhiteSpace(newNetRole)) return;
        var hourly = newNetHourly > 0 ? newNetHourly : Math.Round(newNetDaily / 8m, 3);
        var rr = new ResourceRate { Role = newNetRole!, Type = ResourceType.FTE, DailyRate = newNetDaily, HourlyRate = hourly, IsNetNew = newNetIsHire };
        rr.SourceKey = $"NET-{Guid.NewGuid():N}";
        rr.SourceTeamName = "NetNew";
        estimate!.ResourceRates.Add(rr);
        EnsureStaticNumbersAssigned();

    }

    private void RemoveResourceFromAssignments(string removedKey)
    {
        // Remove the key from all functional line AssignedResources dictionaries
        foreach (var f in estimate!.FunctionalItems)
        {
            var dict = f.AssignedResources;
            if (dict != null && dict.ContainsKey(removedKey))
            {
                dict.Remove(removedKey);
                f.AssignedResources = dict;
            }
        }
        // Remove mapping entry from resourceNumberMap
        var kv = resourceNumberMap.FirstOrDefault(kvp => string.Equals(kvp.Key, removedKey, StringComparison.OrdinalIgnoreCase));
        if (!string.IsNullOrEmpty(kv.Key)) resourceNumberMap.Remove(kv.Key);
    }

    // Ensure each ResourceRate has a stable StaticNumber preserved across rebuilds
    private void EnsureStaticNumbersAssigned()
    {
        if (estimate is null) return;
        // Determine the next available number
        int nextNumber = resourceNumberMap.Values.DefaultIfEmpty(0).Max();
        foreach (var r in estimate.ResourceRates)
        {
            if (string.IsNullOrWhiteSpace(r.SourceKey)) continue;
            if (resourceNumberMap.TryGetValue(r.SourceKey, out var existing))
            {
                r.StaticNumber = existing;
            }
            else
            {
                // allocate a new stable number
                nextNumber++;
                while (resourceNumberMap.Values.Contains(nextNumber)) nextNumber++;
                resourceNumberMap[r.SourceKey] = nextNumber;
                r.StaticNumber = nextNumber;
            }
        }
    }

    // Toggle an assignment on/off for a functional line
    private void ToggleAssignment(FunctionalLineItem f, string sourceKey, bool assign)
    {
        var dict = f.AssignedResources ?? new Dictionary<string, decimal>(StringComparer.OrdinalIgnoreCase);
        if (assign)
        {
            if (!dict.ContainsKey(sourceKey)) dict[sourceKey] = 100m; // default to 100% if newly assigned
        }
        else
        {
            if (dict.ContainsKey(sourceKey)) dict.Remove(sourceKey);
        }
        f.AssignedResources = dict;
        StateHasChanged();
    }

    private void OnCheckboxChanged(FunctionalLineItem f, string sourceKey, ChangeEventArgs e)
    {
        bool assign = false;
        if (e?.Value is bool b) assign = b;
        else if (e?.Value is string s) assign = s.Equals("on", StringComparison.OrdinalIgnoreCase) || s.Equals("true", StringComparison.OrdinalIgnoreCase);
        ToggleAssignment(f, sourceKey, assign);
        MarkAsChanged();
    }

    // Update percent utilisation for an assigned resource
    private void UpdateAssignmentPct(FunctionalLineItem f, string sourceKey, ChangeEventArgs e)
    {
        if (e?.Value is null) return;
        var str = e.Value.ToString();
        if (!decimal.TryParse(str, out var pct)) return;
        pct = Math.Clamp(pct, 0m, 100m);
        var dict = f.AssignedResources ?? new Dictionary<string, decimal>(StringComparer.OrdinalIgnoreCase);
        if (dict.ContainsKey(sourceKey))
        {
            dict[sourceKey] = pct;
            f.AssignedResources = dict;
            MarkAsChanged();
        }
    }

    // Format a friendly label for a resource: "Team skill number"
    private string FormatResourceLabel(ResourceRate r)
    {
        var team = string.IsNullOrWhiteSpace(r.SourceTeamName) ? "NetNew" : r.SourceTeamName;
        var role = string.IsNullOrWhiteSpace(r.Role) ? "Role" : r.Role;
        var employmentType = r.Type == ResourceType.FTE ? "FTE" : "Contractor";
        var hourlyRate = r.HourlyRate > 0 ? r.HourlyRate : Math.Round(r.DailyRate / 8m, 2);
        return $"{team} {role} {r.StaticNumber} ({employmentType} - {r.DailyRate.ToString("C")}/day, {hourlyRate.ToString("C")}/hr)";
    }

    // Compute the cost of a functional line from its assigned resources and utilisation
    private decimal GetFunctionalLineCost(FunctionalLineItem f)
    {
        if (estimate is null) return 0m;
        var lineDays = f.Sprints * estimate.SprintLengthDays;
        decimal total = 0m;
        var dict = f.AssignedResources ?? new Dictionary<string, decimal>(StringComparer.OrdinalIgnoreCase);
        foreach (var kv in dict)
        {
            var key = kv.Key;
            var pct = Math.Clamp(kv.Value, 0m, 100m) / 100m;
            var rate = estimate.ResourceRates.FirstOrDefault(r => string.Equals(r.SourceKey, key, StringComparison.OrdinalIgnoreCase));
            if (rate is null) continue;
            var daily = rate.DailyRate;
            total += daily * lineDays * pct;
        }
        return Decimal.Round(total, 2);
    }

    private async Task Save(bool isAutoSave = false)
    {
        if (estimate is null) return;
        
        if (isAutoSave)
        {
            isAutoSaving = true;
        }
        else
        {
            isSaving = true;
        }
        
        saveMessage = null;
        try
        {
            // Ensure the entity is being tracked by EF
            if (Db.Entry(estimate).State == EntityState.Detached)
            {
                Db.Estimates.Attach(estimate);
                Db.Entry(estimate).State = EntityState.Modified;
            }
            
            // Recalculate and persist costs for lines and totals so they reflect the values at save time
            foreach (var f in estimate.FunctionalItems)
            {
                f.Cost = GetFunctionalLineCost(f);
                // Only attach and mark as modified if detached
                if (Db.Entry(f).State == EntityState.Detached)
                {
                    Db.FunctionalLineItems.Attach(f);
                    Db.Entry(f).State = EntityState.Modified;
                }
            }
            // Non-functional items: either sprints-based or legacy allocations
            foreach (var n in estimate.NonFunctionalItems)
            {
                if (n.Sprints > 0)
                {
                    var squad = new SquadComposition(
                        estimate.ResourceRates.Count(r => r.Type == ResourceType.FTE),
                        estimate.ResourceRates.Count(r => r.Type == ResourceType.Contractor),
                        estimate.ResourceRates.Where(r => r.Type == ResourceType.FTE).DefaultIfEmpty(new ResourceRate { DailyRate = 0 }).Average(r => r.DailyRate),
                        estimate.ResourceRates.Where(r => r.Type == ResourceType.Contractor).DefaultIfEmpty(new ResourceRate { DailyRate = 0 }).Average(r => r.DailyRate),
                        estimate.SprintLengthDays
                    );
                    var perSprint = Cost.CalcSquadCostPerSprint(squad);
                    n.Cost = Decimal.Round(Cost.CalcFunctionalLineCost(n.Sprints, perSprint), 2);
                }
                else
                {
                    n.Cost = Decimal.Round(CalcNonFunctionalCostWithDefaults(n), 2);
                }
                
                if (Db.Entry(n).State == EntityState.Detached)
                {
                    Db.NonFunctionalItems.Attach(n);
                    Db.Entry(n).State = EntityState.Modified;
                }
            }

            // Totals
            estimate.FunctionalSubtotal = Decimal.Round(estimate.FunctionalItems.Sum(f => f.Cost), 2);
            estimate.NonFunctionalSubtotal = Decimal.Round(estimate.NonFunctionalItems.Sum(n => n.Cost), 2);
            estimate.Subtotal = Decimal.Round(estimate.FunctionalSubtotal + estimate.NonFunctionalSubtotal, 2);
            estimate.Total = Decimal.Round(Cost.ApplyContingency(estimate.Subtotal, estimate.ContingencyPercent), 2);

            estimate.UpdatedAtUtc = DateTime.UtcNow;
            
            // Simple save with concurrency exception handling
            try
            {
                await Db.SaveChangesAsync();
            }
            catch (DbUpdateConcurrencyException ex)
            {
                // Handle concurrency conflict - reload the entity and retry once
                if (isAutoSave)
                {
                    // For auto-save, just silently skip if there's a concurrency conflict
                    // since the user is likely still editing
                    return;
                }
                
                // For manual save, refresh the entity and try again
                foreach (var entry in ex.Entries)
                {
                    await entry.ReloadAsync();
                }
                
                // Recalculate costs again with refreshed data
                foreach (var f in estimate.FunctionalItems)
                {
                    f.Cost = GetFunctionalLineCost(f);
                }
                foreach (var n in estimate.NonFunctionalItems)
                {
                    if (n.Sprints > 0)
                    {
                        var squad = new SquadComposition(
                            estimate.ResourceRates.Count(r => r.Type == ResourceType.FTE),
                            estimate.ResourceRates.Count(r => r.Type == ResourceType.Contractor),
                            estimate.ResourceRates.Where(r => r.Type == ResourceType.FTE).DefaultIfEmpty(new ResourceRate { DailyRate = 0 }).Average(r => r.DailyRate),
                            estimate.ResourceRates.Where(r => r.Type == ResourceType.Contractor).DefaultIfEmpty(new ResourceRate { DailyRate = 0 }).Average(r => r.DailyRate),
                            estimate.SprintLengthDays
                        );
                        var perSprint = Cost.CalcSquadCostPerSprint(squad);
                        n.Cost = Decimal.Round(Cost.CalcFunctionalLineCost(n.Sprints, perSprint), 2);
                    }
                    else
                    {
                        n.Cost = Decimal.Round(CalcNonFunctionalCostWithDefaults(n), 2);
                    }
                }
                
                // Recalculate totals
                estimate.FunctionalSubtotal = Decimal.Round(estimate.FunctionalItems.Sum(f => f.Cost), 2);
                estimate.NonFunctionalSubtotal = Decimal.Round(estimate.NonFunctionalItems.Sum(n => n.Cost), 2);
                estimate.Subtotal = Decimal.Round(estimate.FunctionalSubtotal + estimate.NonFunctionalSubtotal, 2);
                estimate.Total = Decimal.Round(Cost.ApplyContingency(estimate.Subtotal, estimate.ContingencyPercent), 2);
                estimate.UpdatedAtUtc = DateTime.UtcNow;
                
                // Retry save once
                await Db.SaveChangesAsync();
            }
            
            hasUnsavedChanges = false;
            
            if (isAutoSave)
            {
                saveMessage = "Auto-saved";
            }
            else
            {
                saveMessage = "Saved";
            }
            saveMessageClass = "text-success";
        }
        catch (Exception ex)
        {
            saveMessage = (isAutoSave ? "Auto-save failed: " : "Save failed: ") + ex.Message;
            saveMessageClass = "text-danger";
        }
        finally
        {
            if (isAutoSave)
            {
                isAutoSaving = false;
            }
            else
            {
                isSaving = false;
            }
            StateHasChanged();
        }
    }

    private async Task Clone()
    {
        var clone = new Estimate
        {
            Name = estimate!.Name + " (Clone)",
            Client = estimate.Client,
            SprintLengthDays = estimate.SprintLengthDays,
            ContingencyPercent = estimate.ContingencyPercent,
            Version = estimate.Version + 1,
            ClonedFromEstimateId = estimate.Id
        };
        foreach (var r in estimate.ResourceRates)
            clone.ResourceRates.Add(new ResourceRate { Role = r.Role, Type = r.Type, DailyRate = r.DailyRate, HourlyRate = r.HourlyRate });
        foreach (var f in estimate.FunctionalItems)
            clone.FunctionalItems.Add(new FunctionalLineItem { Title = f.Title, SourceType = f.SourceType, PatternKey = f.PatternKey, AverageSprints = f.AverageSprints, Sprints = f.Sprints });
        foreach (var n in estimate.NonFunctionalItems)
        {
            var newN = new NonFunctionalItem { Title = n.Title };
            foreach (var a in n.Allocations)
                newN.Allocations.Add(new ResourceAllocation { Role = a.Role, Hours = a.Hours });
            clone.NonFunctionalItems.Add(newN);
        }
        Db.Estimates.Add(clone);
        await Db.SaveChangesAsync();
        Nav.NavigateTo($"/estimate/{clone.Id}");
    }

    private void AddSuggestedOverheads() => AddAllSupport();

    // Role mapping helpers
    private IEnumerable<string> UnknownRoles => estimate is null
        ? Enumerable.Empty<string>()
        : estimate.NonFunctionalItems.SelectMany(n => n.Allocations.Select(a => a.Role))
            .Where(role => estimate.ResourceRates.All(r => !r.Role.Equals(role, StringComparison.OrdinalIgnoreCase)))
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .Except(estimate.RoleMappings.Select(m => m.SourceRole), StringComparer.OrdinalIgnoreCase);

    private string? ResolveRole(string source)
    {
        var map = estimate?.RoleMappings.FirstOrDefault(m => m.SourceRole.Equals(source, StringComparison.OrdinalIgnoreCase));
        return map?.TargetRole ?? source;
    }

    private void MapRole(string sourceRole, string? targetRole)
    {
        if (estimate is null) return;
        if (string.IsNullOrWhiteSpace(targetRole)) return;
        var existing = estimate.RoleMappings.FirstOrDefault(m => m.SourceRole.Equals(sourceRole, StringComparison.OrdinalIgnoreCase));
        if (existing is null)
        {
            estimate.RoleMappings.Add(new RoleMapping { SourceRole = sourceRole, TargetRole = targetRole });
        }
        else
        {
            existing.TargetRole = targetRole;
        }
        StateHasChanged();
    }

    private bool IsValid => estimate is not null && !string.IsNullOrWhiteSpace(estimate.Name) && estimate.SprintLengthDays > 0 && estimate.ContingencyPercent >= 0 && estimate.ContingencyPercent <= 100;
    
    public void Dispose()
    {
        autoSaveTimer?.Dispose();
    }
}
